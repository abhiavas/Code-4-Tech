import cv2
import numpy as np
from sklearn.ensemble import RandomForestClassifier  # For ambiguous cases
from PIL import Image
import json
import os
import sqlite3

# Hardcoded answer key (example for 100 questions; load from file in production)
ANSWER_KEY = ['A'] * 100  # Placeholder; replace with actual key, e.g., ['B', 'C', 'A', ...]

# Subject ranges (0-indexed)
SUBJECT_RANGES = [(0, 20), (20, 40), (40, 60), (60, 80), (80, 100)]

# Assume bubble ROIs after rectification (in pixels; tune based on sample)
# For each question, 4 bubbles: positions as list of (x, y, w, h) for A, B, C, D
BUBBLE_POSITIONS = []  # Example: Populate with 100 lists, each with 4 tuples
# For demo, assume a grid: questions in rows, options in columns.
# Image size after warp: 1000x1500 (width x height)
for q in range(100):
    y = 100 + q * 20  # Vertical spacing
    bubbles = [(200, y, 30, 30), (250, y, 30, 30), (300, y, 30, 30), (350, y, 30, 30)]  # A B C D
    BUBBLE_POSITIONS.append(bubbles)

# Corner markers for perspective correction (expected positions in template)
MARKER_POS = np.array([[0, 0], [1500, 0], [1500, 1000], [0, 1000]], dtype="float32")

def preprocess_image(image_path):
    img = cv2.imread(image_path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edged = cv2.Canny(blurred, 75, 200)
    
    # Find contours for markers/corners
    contours, _ = cv2.findContours(edged, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    corners = sorted([cv2.boundingRect(c) for c in contours if cv2.contourArea(c) > 1000], key=lambda x: x[0])[:4]  # Assume 4 markers
    
    # Approximate corners
    src_pts = np.array([ (c[0], c[1]) for c in corners ], dtype="float32")
    # Sort points: top-left, top-right, bottom-right, bottom-left
    src_pts = src_pts[np.argsort(src_pts[:, 1])]  # Sort by y
    top = src_pts[:2][np.argsort(src_pts[:2, 0])]
    bottom = src_pts[2:][np.argsort(src_pts[2:, 0])]
    src_pts = np.array([top[0], top[1], bottom[1], bottom[0]])
    
    # Perspective transform
    M = cv2.getPerspectiveTransform(src_pts, MARKER_POS)
    warped = cv2.warpPerspective(gray, M, (1500, 1000))
    
    # Adaptive thresholding for illumination
    thresh = cv2.adaptiveThreshold(warped, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2)
    return thresh, warped  # Return binary and grayscale

def detect_bubbles(thresh, gray):
    answers = []
    for q, bubbles in enumerate(BUBBLE_POSITIONS):
        scores = []
        for roi in bubbles:
            x, y, w, h = roi
            bubble_img = thresh[y:y+h, x:x+w]
            filled_ratio = np.sum(bubble_img == 255) / (w * h)  # White pixels in inverted thresh
            scores.append(filled_ratio)
        
        # Determine marked option
        if max(scores) > 0.5:  # Threshold for marked
            option = 'ABCD'[np.argmax(scores)]
        else:
            option = None  # Unmarked
        answers.append(option)
    return answers

def classify_ambiguous(gray_rois):  # Optional ML for edge cases
    # Train a simple classifier on features (e.g., mean intensity, std)
    features = [np.array([np.mean(roi), np.std(roi)]) for roi in gray_rois]
    clf = RandomForestClassifier()  # Assume pre-trained; in practice, train on labeled data
    # clf.fit(X_train, y_train)  # Skipped for demo
    return clf.predict(features)  # 1 for filled, 0 for empty

def evaluate_answers(answers):
    scores = []
    for start, end in SUBJECT_RANGES:
        subject_score = sum(1 for i in range(start, end) if answers[i] == ANSWER_KEY[i])
        scores.append(subject_score)
    total = sum(scores)
    return scores, total

def store_results(student_id, scores, total, image_path, db_path='results.db'):
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS results (student_id TEXT, subject1 INT, subject2 INT, subject3 INT, subject4 INT, subject5 INT, total INT)''')
    c.execute('INSERT INTO results VALUES (?, ?, ?, ?, ?, ?, ?)', (student_id, *scores, total))
    conn.commit()
    conn.close()
    
    # Save overlaid image for audit
    overlay = cv2.imread(image_path)  # TODO: Add overlays
    cv2.imwrite(f'audit/{student_id}.jpg', overlay)

# Example usage
if __name__ == "__main__":
    thresh, warped = preprocess_image('sample_sheet.jpg')
    answers = detect_bubbles(thresh, warped)
    scores, total = evaluate_answers(answers)
    store_results('student001', scores, total, 'sample_sheet.jpg')
    print(f"Scores: {scores}, Total: {total}")
